/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/@microsoft/signalr@6.0.4/dist/esm/HttpConnection.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{DefaultHttpClient}from"./DefaultHttpClient";import{AggregateErrors,DisabledTransportError,FailedToNegotiateWithServerError,FailedToStartTransportError,HttpError,UnsupportedTransportError}from"./Errors";import{HeaderNames}from"./HeaderNames";import{LogLevel}from"./ILogger";import{HttpTransportType,TransferFormat}from"./ITransport";import{LongPollingTransport}from"./LongPollingTransport";import{ServerSentEventsTransport}from"./ServerSentEventsTransport";import{Arg,createLogger,getUserAgentHeader,Platform}from"./Utils";import{WebSocketTransport}from"./WebSocketTransport";const MAX_REDIRECTS=100;export class HttpConnection{constructor(t,e={}){if(this._stopPromiseResolver=()=>{},this.features={},this._negotiateVersion=1,Arg.isRequired(t,"url"),this._logger=createLogger(e.logger),this.baseUrl=this._resolveUrl(t),(e=e||{}).logMessageContent=void 0!==e.logMessageContent&&e.logMessageContent,"boolean"!=typeof e.withCredentials&&void 0!==e.withCredentials)throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");e.withCredentials=void 0===e.withCredentials||e.withCredentials,e.timeout=void 0===e.timeout?1e5:e.timeout;let o=null,r=null;if(Platform.isNode&&"undefined"!=typeof require){const t="function"==typeof __webpack_require__?__non_webpack_require__:require;o=t("ws"),r=t("eventsource")}Platform.isNode||"undefined"==typeof WebSocket||e.WebSocket?Platform.isNode&&!e.WebSocket&&o&&(e.WebSocket=o):e.WebSocket=WebSocket,Platform.isNode||"undefined"==typeof EventSource||e.EventSource?Platform.isNode&&!e.EventSource&&void 0!==r&&(e.EventSource=r):e.EventSource=EventSource,this._httpClient=e.httpClient||new DefaultHttpClient(this._logger),this._connectionState="Disconnected",this._connectionStarted=!1,this._options=e,this.onreceive=null,this.onclose=null}async start(t){if(t=t||TransferFormat.Binary,Arg.isIn(t,TransferFormat,"transferFormat"),this._logger.log(LogLevel.Debug,`Starting connection with transfer format '${TransferFormat[t]}'.`),"Disconnected"!==this._connectionState)return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));if(this._connectionState="Connecting",this._startInternalPromise=this._startInternal(t),await this._startInternalPromise,"Disconnecting"===this._connectionState){const t="Failed to start the HttpConnection before stop() was called.";return this._logger.log(LogLevel.Error,t),await this._stopPromise,Promise.reject(new Error(t))}if("Connected"!==this._connectionState){const t="HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";return this._logger.log(LogLevel.Error,t),Promise.reject(new Error(t))}this._connectionStarted=!0}send(t){return"Connected"!==this._connectionState?Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")):(this._sendQueue||(this._sendQueue=new TransportSendQueue(this.transport)),this._sendQueue.send(t))}async stop(t){return"Disconnected"===this._connectionState?(this._logger.log(LogLevel.Debug,`Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnected state.`),Promise.resolve()):"Disconnecting"===this._connectionState?(this._logger.log(LogLevel.Debug,`Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnecting state.`),this._stopPromise):(this._connectionState="Disconnecting",this._stopPromise=new Promise((t=>{this._stopPromiseResolver=t})),await this._stopInternal(t),void await this._stopPromise)}async _stopInternal(t){this._stopError=t;try{await this._startInternalPromise}catch(t){}if(this.transport){try{await this.transport.stop()}catch(t){this._logger.log(LogLevel.Error,`HttpConnection.transport.stop() threw error '${t}'.`),this._stopConnection()}this.transport=void 0}else this._logger.log(LogLevel.Debug,"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.")}async _startInternal(t){let e=this.baseUrl;this._accessTokenFactory=this._options.accessTokenFactory;try{if(this._options.skipNegotiation){if(this._options.transport!==HttpTransportType.WebSockets)throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");this.transport=this._constructTransport(HttpTransportType.WebSockets),await this._startTransport(e,t)}else{let o=null,r=0;do{if(o=await this._getNegotiationResponse(e),"Disconnecting"===this._connectionState||"Disconnected"===this._connectionState)throw new Error("The connection was stopped during negotiation.");if(o.error)throw new Error(o.error);if(o.ProtocolVersion)throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");if(o.url&&(e=o.url),o.accessToken){const t=o.accessToken;this._accessTokenFactory=()=>t}r++}while(o.url&&r<100);if(100===r&&o.url)throw new Error("Negotiate redirection limit exceeded.");await this._createTransport(e,this._options.transport,o,t)}this.transport instanceof LongPollingTransport&&(this.features.inherentKeepAlive=!0),"Connecting"===this._connectionState&&(this._logger.log(LogLevel.Debug,"The HttpConnection connected successfully."),this._connectionState="Connected")}catch(t){return this._logger.log(LogLevel.Error,"Failed to start the connection: "+t),this._connectionState="Disconnected",this.transport=void 0,this._stopPromiseResolver(),Promise.reject(t)}}async _getNegotiationResponse(t){const e={};if(this._accessTokenFactory){const t=await this._accessTokenFactory();t&&(e[HeaderNames.Authorization]=`Bearer ${t}`)}const[o,r]=getUserAgentHeader();e[o]=r;const n=this._resolveNegotiateUrl(t);this._logger.log(LogLevel.Debug,`Sending negotiation request: ${n}.`);try{const t=await this._httpClient.post(n,{content:"",headers:{...e,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials});if(200!==t.statusCode)return Promise.reject(new Error(`Unexpected status code returned from negotiate '${t.statusCode}'`));const o=JSON.parse(t.content);return(!o.negotiateVersion||o.negotiateVersion<1)&&(o.connectionToken=o.connectionId),o}catch(t){let e="Failed to complete negotiation with the server: "+t;return t instanceof HttpError&&404===t.statusCode&&(e+=" Either this is not a SignalR endpoint or there is a proxy blocking the connection."),this._logger.log(LogLevel.Error,e),Promise.reject(new FailedToNegotiateWithServerError(e))}}_createConnectUrl(t,e){return e?t+(-1===t.indexOf("?")?"?":"&")+`id=${e}`:t}async _createTransport(t,e,o,r){let n=this._createConnectUrl(t,o.connectionToken);if(this._isITransport(e))return this._logger.log(LogLevel.Debug,"Connection was provided an instance of ITransport, using that directly."),this.transport=e,await this._startTransport(n,r),void(this.connectionId=o.connectionId);const s=[],i=o.availableTransports||[];let a=o;for(const o of i){const i=this._resolveTransportOrError(o,e,r);if(i instanceof Error)s.push(`${o.transport} failed:`),s.push(i);else if(this._isITransport(i)){if(this.transport=i,!a){try{a=await this._getNegotiationResponse(t)}catch(t){return Promise.reject(t)}n=this._createConnectUrl(t,a.connectionToken)}try{return await this._startTransport(n,r),void(this.connectionId=a.connectionId)}catch(t){if(this._logger.log(LogLevel.Error,`Failed to start the transport '${o.transport}': ${t}`),a=void 0,s.push(new FailedToStartTransportError(`${o.transport} failed: ${t}`,HttpTransportType[o.transport])),"Connecting"!==this._connectionState){const t="Failed to select transport before stop() was called.";return this._logger.log(LogLevel.Debug,t),Promise.reject(new Error(t))}}}}return s.length>0?Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${s.join(" ")}`,s)):Promise.reject(new Error("None of the transports supported by the client are supported by the server."))}_constructTransport(t){switch(t){case HttpTransportType.WebSockets:if(!this._options.WebSocket)throw new Error("'WebSocket' is not supported in your environment.");return new WebSocketTransport(this._httpClient,this._accessTokenFactory,this._logger,this._options.logMessageContent,this._options.WebSocket,this._options.headers||{});case HttpTransportType.ServerSentEvents:if(!this._options.EventSource)throw new Error("'EventSource' is not supported in your environment.");return new ServerSentEventsTransport(this._httpClient,this._accessTokenFactory,this._logger,this._options);case HttpTransportType.LongPolling:return new LongPollingTransport(this._httpClient,this._accessTokenFactory,this._logger,this._options);default:throw new Error(`Unknown transport: ${t}.`)}}_startTransport(t,e){return this.transport.onreceive=this.onreceive,this.transport.onclose=t=>this._stopConnection(t),this.transport.connect(t,e)}_resolveTransportOrError(t,e,o){const r=HttpTransportType[t.transport];if(null==r)return this._logger.log(LogLevel.Debug,`Skipping transport '${t.transport}' because it is not supported by this client.`),new Error(`Skipping transport '${t.transport}' because it is not supported by this client.`);if(!transportMatches(e,r))return this._logger.log(LogLevel.Debug,`Skipping transport '${HttpTransportType[r]}' because it was disabled by the client.`),new DisabledTransportError(`'${HttpTransportType[r]}' is disabled by the client.`,r);if(!(t.transferFormats.map((t=>TransferFormat[t])).indexOf(o)>=0))return this._logger.log(LogLevel.Debug,`Skipping transport '${HttpTransportType[r]}' because it does not support the requested transfer format '${TransferFormat[o]}'.`),new Error(`'${HttpTransportType[r]}' does not support ${TransferFormat[o]}.`);if(r===HttpTransportType.WebSockets&&!this._options.WebSocket||r===HttpTransportType.ServerSentEvents&&!this._options.EventSource)return this._logger.log(LogLevel.Debug,`Skipping transport '${HttpTransportType[r]}' because it is not supported in your environment.'`),new UnsupportedTransportError(`'${HttpTransportType[r]}' is not supported in your environment.`,r);this._logger.log(LogLevel.Debug,`Selecting transport '${HttpTransportType[r]}'.`);try{return this._constructTransport(r)}catch(t){return t}}_isITransport(t){return t&&"object"==typeof t&&"connect"in t}_stopConnection(t){if(this._logger.log(LogLevel.Debug,`HttpConnection.stopConnection(${t}) called while in state ${this._connectionState}.`),this.transport=void 0,t=this._stopError||t,this._stopError=void 0,"Disconnected"!==this._connectionState){if("Connecting"===this._connectionState)throw this._logger.log(LogLevel.Warning,`Call to HttpConnection.stopConnection(${t}) was ignored because the connection is still in the connecting state.`),new Error(`HttpConnection.stopConnection(${t}) was called while the connection is still in the connecting state.`);if("Disconnecting"===this._connectionState&&this._stopPromiseResolver(),t?this._logger.log(LogLevel.Error,`Connection disconnected with error '${t}'.`):this._logger.log(LogLevel.Information,"Connection disconnected."),this._sendQueue&&(this._sendQueue.stop().catch((t=>{this._logger.log(LogLevel.Error,`TransportSendQueue.stop() threw error '${t}'.`)})),this._sendQueue=void 0),this.connectionId=void 0,this._connectionState="Disconnected",this._connectionStarted){this._connectionStarted=!1;try{this.onclose&&this.onclose(t)}catch(e){this._logger.log(LogLevel.Error,`HttpConnection.onclose(${t}) threw error '${e}'.`)}}}else this._logger.log(LogLevel.Debug,`Call to HttpConnection.stopConnection(${t}) was ignored because the connection is already in the disconnected state.`)}_resolveUrl(t){if(0===t.lastIndexOf("https://",0)||0===t.lastIndexOf("http://",0))return t;if(!Platform.isBrowser)throw new Error(`Cannot resolve '${t}'.`);const e=window.document.createElement("a");return e.href=t,this._logger.log(LogLevel.Information,`Normalizing '${t}' to '${e.href}'.`),e.href}_resolveNegotiateUrl(t){const e=t.indexOf("?");let o=t.substring(0,-1===e?t.length:e);return"/"!==o[o.length-1]&&(o+="/"),o+="negotiate",o+=-1===e?"":t.substring(e),-1===o.indexOf("negotiateVersion")&&(o+=-1===e?"?":"&",o+="negotiateVersion="+this._negotiateVersion),o}}function transportMatches(t,e){return!t||0!=(e&t)}export class TransportSendQueue{constructor(t){this._transport=t,this._buffer=[],this._executing=!0,this._sendBufferedData=new PromiseSource,this._transportResult=new PromiseSource,this._sendLoopPromise=this._sendLoop()}send(t){return this._bufferData(t),this._transportResult||(this._transportResult=new PromiseSource),this._transportResult.promise}stop(){return this._executing=!1,this._sendBufferedData.resolve(),this._sendLoopPromise}_bufferData(t){if(this._buffer.length&&typeof this._buffer[0]!=typeof t)throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof t}`);this._buffer.push(t),this._sendBufferedData.resolve()}async _sendLoop(){for(;;){if(await this._sendBufferedData.promise,!this._executing){this._transportResult&&this._transportResult.reject("Connection stopped.");break}this._sendBufferedData=new PromiseSource;const t=this._transportResult;this._transportResult=void 0;const e="string"==typeof this._buffer[0]?this._buffer.join(""):TransportSendQueue._concatBuffers(this._buffer);this._buffer.length=0;try{await this._transport.send(e),t.resolve()}catch(e){t.reject(e)}}}static _concatBuffers(t){const e=t.map((t=>t.byteLength)).reduce(((t,e)=>t+e)),o=new Uint8Array(e);let r=0;for(const e of t)o.set(new Uint8Array(e),r),r+=e.byteLength;return o.buffer}}class PromiseSource{constructor(){this.promise=new Promise(((t,e)=>[this._resolver,this._rejecter]=[t,e]))}resolve(){this._resolver()}reject(t){this._rejecter(t)}}
//# sourceMappingURL=/sm/5453f923bff6285ebc13ebcfb179c6977ecf8e766ec27db391d72d130fd37a85.map